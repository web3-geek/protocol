import del from 'rollup-plugin-delete'
import resolve from '@rollup/plugin-node-resolve';
import commonjs from '@rollup/plugin-commonjs';
import { createFilter } from '@rollup/pluginutils';
import { parse } from '@babel/parser';
import { default as _generate } from '@babel/generator';
import t from '@babel/types';
import _traverse from '@babel/traverse';
import { identifier } from '@babel/types';
import fs from 'node:fs';

const traverse = _traverse.default;
const generate = _generate.default;

const entries = {}; 
fs.readdirSync('./src/core/contract').map(item => {
  entries[item.replace('.js', '')] = `src/core/contract/${item}`;
});
export default {
  input: {
    // 'google-protobuf': 'src/index.js',
    // 'any_pb': 'src/any_pb.js',
    Tron_pb: 'src/core/Tron_pb.js',
    ...entries,
  },
  output: {
    entryFileNames: '[name].ts',
    chunkFileNames: '[name]-[hash].ts',
    dir: 'dist',
    format: 'es',
    banner: "/* Generated by rollup. Don't edit it. */\n // @ts-nocheck"
  },
  external: ['@tronweb3/google-protobuf'],
  plugins: [del({ targets: 'dist/*' }), transformRequirePlugin({ include: 'src/core/**/*' }), resolve(), commonjs()]
};

function transformRequirePlugin(options = {}) {
  const filter = createFilter(options.include, options.exclude);
  return {
    name: 'transform-code',
    transform(code, id) {
      const newcode = code
      // remove extend proto
      .replace('goog.object.extend(proto, core_Tron_pb);', '')  
      // replace "proto.protocol.Transaction = " with "export const Transaction = "
      .replaceAll(/proto\.protocol\.(\w+)\s*=/g, ($0, $1) => {
        return `export const ${$1} =`
      })
      // replace "proto.protocol.Transaction" with "Transaction"
      .replaceAll('proto.protocol.', '')
      // remove extend exports
      .replace('goog.object.extend(exports, proto.protocol);', '');
      if (!filter(id)) return;
      const ast = parse(newcode, {
        sourceType: 'module'
      });
      const usedTronPbMessage = [];
      traverse(ast, {
        MemberExpression(path) {
          // if some Message use core_Tron_pb.Permission, change it to Permission
          if (t.isIdentifier(path.node.object, { name: 'core_Tron_pb' })) {
            const name = path.node.property.name;
            !usedTronPbMessage.includes(name) && usedTronPbMessage.push(name);
            path.replaceWith(path.node.property);
          }
        }
      })
      traverse(ast, {
        VariableDeclaration: function (path) {
          const cur = path;
          if (path.parent.type !== 'Program' || !path.node.declarations || !path.node.declarations[0]) {
            return;
          }
          const declarator = path.node.declarations[0];
          if (!t.isCallExpression(declarator.init) || declarator.init.callee?.name !== 'require') {
            return;
          }
          const argument = declarator.init.arguments[0];
          if (!argument) {
            return;
          }
          const name = declarator.id.name;
          const lib = argument.value;
          if (lib.startsWith('google-protobuf')) {
            // change `const jsbp = require("google-protobuf")` to 
            cur.replaceWith(
              t.importDeclaration([t.importNamespaceSpecifier(t.identifier(name))], t.stringLiteral('@tronweb3/' + lib))
            );
          }
          if (name === 'core_Tron_pb') {
            if (usedTronPbMessage.length > 0) {
              // change `const core_Tron_pb = require()` to `import {} from ''`
              cur.replaceWith(
                t.importDeclaration(usedTronPbMessage.map(message => t.importSpecifier(t.identifier(message), t.stringLiteral(message))), t.stringLiteral(lib))
              );
            } else {
              cur.remove();
            }
          }
        },
        ExpressionStatement(path) {
          const { start, end } = path.node;
          if (newcode.slice(start, end).startsWith('goog.exportSymbol(')) {
            path.remove();
          }
        }
      });
      const output = generate(
        ast,
        {
          /* options */
        },
        code
      );
      // proceed with the transformation...
      return {
        code: output.code,
        map: output.map
      };
    }
  };
}
